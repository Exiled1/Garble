//! Handles the handshake/key exchange.

use crate::crypto::{self, SessionKey};
use crate::message;
use futures::SinkExt;
use openssl::{pkey::Private, rsa::Rsa};
use thiserror::Error;
use tokio::net::TcpStream;
use tokio_stream::StreamExt;
use tokio_util::codec::Decoder;

use super::{ChatClient, ClientError, MessageStream};

/// An error that can occur while setting up a connection.
#[derive(Error, Debug)]
pub enum ConnectError {
    #[error(transparent)]
    ClientError(#[from] ClientError),

    #[error("connection failed: {reason}")]
    ConnectRefused {
        connector: ChatConnector,
        reason: String,
    },

    // this error message gets an exclamation point because it means someone tried to attack you
    #[error("key {key:?} does not match requested fingerprint {fingerprint}!")]
    FingerprintMismatch { fingerprint: String, key: Vec<u8> },
}

/// Handles the key exchange process.
#[derive(Debug)]
pub struct ChatConnector {
    tcp_stream: MessageStream,
    pub keypair: Rsa<Private>,
}

impl ChatConnector {
    /// Creates a connection to the specified server, generating a key pair & registering it.
    pub async fn new(hostname: &str, port: usize) -> Result<Self, ClientError> {
        let keypair = crypto::generate_keypair(None)?;

        // TcpStream is not a stream, it's a stream of bytes (NOT A STREAM), I guess it's an AsyncRead/AsyncWrite.
        let not_a_stream = TcpStream::connect(format!("{hostname}:{port}")).await?;
        let mut message_stream = message::MessageCodec::default().framed(not_a_stream);

        message_stream
            .send(message::Serverbound::Hello {
                public_key: keypair.public_key_to_der()?,
            })
            .await?;

        Ok(Self {
            tcp_stream: message_stream,
            keypair,
        })
    }

    /// Requests a chat session with the peer having the specified public key fingerprint.
    pub async fn request_connection(
        mut self,
        peer_fingerprint: String,
    ) -> Result<ChatClient, ConnectError> {
        self.tcp_stream
            .send(message::Serverbound::ConnectRequest {
                peer_fingerprint: peer_fingerprint.clone(),
            })
            .await
            .map_err(ClientError::from)?;

        loop {
            match self.tcp_stream.next().await {
                Some(Ok(message::Clientbound::ConnectWaiting)) => continue,

                // The server has asked us to choose the session key.
                Some(Ok(message::Clientbound::ChooseKey { dst_public_key })) => {
                    // Make sure the peer's public key has the correct fingerprint
                    if crypto::sha3_256_base64(&dst_public_key) != peer_fingerprint {
                        return Err(ConnectError::FingerprintMismatch {
                            fingerprint: peer_fingerprint,
                            key: dst_public_key,
                        });
                    }

                    let dst_public_key =
                        Rsa::public_key_from_der(&dst_public_key).map_err(ClientError::from)?;

                    // Generate a temporary AES key for the session.
                    let key = SessionKey::generate().map_err(ClientError::from)?;

                    // Encrypt it with the peer's public key, and sign it with our private key.
                    let (encrypted, signature) = key
                        .encrypt_session_key(dst_public_key.as_ref(), self.keypair.as_ref())
                        .map_err(ClientError::from)?;

                    // Send the encyrpted key to the other client.
                    self.tcp_stream
                        .send(message::Serverbound::UseKey {
                            session_key: encrypted,
                            signature,
                        })
                        .await
                        .map_err(ClientError::from)?;
                    break Ok(ChatClient::new(self.tcp_stream, key));
                }
                Some(Ok(message::Clientbound::UseKey {
                    dst_public_key,
                    session_key,
                    signature,
                })) => {
                    // The server has asked us to use a session key generated by the remote peer.
                    // Make sure the peer's public key has the correct fingerprint
                    if crypto::sha3_256_base64(&dst_public_key) != peer_fingerprint {
                        return Err(ConnectError::FingerprintMismatch {
                            fingerprint: peer_fingerprint,
                            key: dst_public_key,
                        });
                    }

                    let dst_public_key =
                        Rsa::public_key_from_der(&dst_public_key).map_err(ClientError::from)?;
                    let session_key = SessionKey::decrypt_session_key(
                        session_key,
                        signature,
                        self.keypair.as_ref(),
                        dst_public_key.as_ref(),
                    )?;

                    break Ok(ChatClient::new(self.tcp_stream, session_key));
                }
                Some(Ok(message::Clientbound::ConnectFail { reason })) => {
                    // The server could not connect us to the peer.
                    break Err(ConnectError::ConnectRefused {
                        connector: self,
                        reason,
                    });
                }

                Some(Ok(message::Clientbound::Shutdown { message })) => {
                    // The server is terminating our connection.
                    break Err(ConnectError::from(ClientError::ServerShutdown {
                        reason: message,
                    }));
                }
                None => {
                    // The stream closed.
                    break Err(ConnectError::from(ClientError::ServerShutdown {
                        reason: "socket closed by remote server".to_string(),
                    }));
                }

                Some(Ok(message)) => {
                    // Some other message that doesn't make any sense in this context
                    break Err(ConnectError::from(ClientError::InvalidMessage { message }));
                }

                Some(Err(e)) => break Err(ConnectError::from(ClientError::IoError(e))),
            }
        }
    }
}
